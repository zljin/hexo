---
title: coreJava
date: 2021-03-07 12:00:45
tags: 技术
categories: java
---

> 代码路径：https://gitee.com/zou0jin/lingJinCode

#### 基础语法
1. 关键字：定义的一些具有特殊用途的单词

```
权限关键字：public(公共),private(本类),default(同包可访问),protected(继承关系可访问)
static：静态修饰符
    1. 随着类加载而加载,和类一起最新加载
    2. 该类所有对象共享
    3. 静态不能访问非静态(先人不知后人)
final：
    1.类不能继承和方法不能重写
    2.基本类型数值不变
    3.引用类型引用不变
```

2. 标识符：给程序中的变量、类、方法命名的符号
3. 数据类型：分为基本数据类型、包装类型、引用类型
4. 运算符：给程序进行数据的运算,赋值,比较的符号
5. 流程控制：分支结构和循环结构
6. ==和equals有那些区别

```
1. ==是运算符 一个是方法
2. ==如果比较基本数据类型就是比较数值是否相等,比较对象则是比较地址是否相等
3. equals()用来比较对象的内容是否相等,是Object的方法,子类都可重写判断逻辑,
如String,默认是比较引用地址是否相同
```

7. java中的参数传递时值传递吗

```
java中的参数传递都是值传递(看成副本传递更好理解) 
    a.基本类型的变量保存原始值，即它代表的值就是数值本身；
    b.引用类型的变量保存的值是引用值("引用值"指向内存空间的地址,代表某一个对象的引用而不是对象本身)
    c.包装类因为会自动装箱拆箱，所以可以和基本类型一样处理
```

#### 面向对象
> 类是一个具有相同特征和相同行为的抽象描述,对象是通过类创建具体实例.如人和人类的概念。人类有特征和行为,属性和方法对于其特征和行为

1. 三大特征：封装，继承，多态

```
封装：将公共的数据和复杂行为进行隐藏,并提供对外访问接口 

继承：子类继承父类的属性和方法,并可以重写方法和属性 [单继承][多实现]

多态：同一种类型的事物具有多种不同的表现形式,基于继承的父类对象引用其多个子类对象
重写是实现运行时的多态,重载时编译时的多态
对于成员方法:编译看左边,运行看右边 
对于全局变量||静态方法->编译看左,运行看左
```

2. 接口和抽象类

```
接口:
    1. 多实现 
    2. 方法默认被public abstract修饰 
    3. 变量默认被public static final修时(常量)
    4. jdk8之后可以在接口定义static方法和default方法并有方法体
抽象类:
    1. 单继承 
    2. 可定义构造器 
    3. 可以有抽象方法和具体方法 
    4. 可以定义成员变量 

语义上的区别: 接口常用在共同特征中  抽象类常用在抽象概念中
```

3. 方法重写和重载

```
重载：方法名相同,参数列表不同 重写：子类覆盖父类的方法

都是实现多态的一种方式,重写是实现运行时的多态性，重载时编译时的多态性
重写是继承父类的方法而进行重写，final修饰的方法不能重写,static不能重写，只能再次声明，构造方法不能重写
重写的方法要比父类方法越来越强，如抛出的异常越来越小，权限修饰符越来越大
重载在一个类中方法名相同,参数列表不同(参数类型不同,参数个数不同)
```

4. 构造方法:创建对象并对全局进行初始化
> 类的初始化顺序:静态变量,静态语句块,实例变量,普通语句块,构造函数 <br>

5. static

```
静态变量:称为类变量,类的所有实例所共享,可通过类名直接访问,静态变量在内存中只存在一份
静态方法:类加载时就存在,不依赖任何实例,所以静态方法必须实现,不能有抽象方法
静态代码块: 用于一次性对静态变量进行赋值且在类初始化时只运行一次
静态内部类
```


#### 容器
1. Collection 单列集合接口 

```
子类:
List(有序,可重复) Set(无序,不可重复)
> HashSet -主要用于数据检索,通过Hash值排序
> TreeSet - 内部是按照元素的字典顺序进行排序的,泛型类需要实现Comparable接口

Comparable与Comparator

父类：Iterable是集合的顶级接口之一
实现这个接口的类具有可迭代性,里面有Iterator()方法用于迭代遍历集合元素
意义在于创建新的Iterable不用担心Iterator指针问题,互不影响
```


2. Array 数组,其元素类型都相同,数组长度固定不变,必须初始化

3. Map 双列集合接口

```
HashMap简要介绍：
底层结构：数组+链表(扩容后变为红黑树) 负载因子0.75
将（k,v）的值push进去的时候有以下过程

1. 先将k通过hash函数进行翻译，其翻译的值就是存放数组的地址值
2. 如果此地址不为空，则将该数据以链表的形式插入到该数组坐标的的尾结点中
```


#### 多线程

> java 并发概率基础：http://www.imooc.com/wiki/concurrencylesson
> java 并发工具：http://www.imooc.com/wiki/ctoolslesson/concurrentintro.html
> 线程池调优：https://blog.csdn.net/qq_35971258/article/details/115268948


1. 并发工具用过哪些

```
原子操作类：
AtomicInteger 进行i++的原子增加
同步工具：
CountDownLatch 倒时计数器，每次执行一个多线程，计数器减去1,当减为0的时候,主线程开始执行
CyclicBarrier 循环屏障,允许一组线程相互等待,直到所有线程到达一个公共的屏障点,这些进程再一起执行后续的逻辑,此屏障和重复使用
并发容器：
ConcurrentHashMap 统计文本的字母出现的次数 采用map结构进行存储,为了提高效率，我们用4个线程去处理提高效率。多个线程去操作同一个map统计
BlockingQueue 阻塞队列。先入先出不允许插队
CopyOnWriteArrayList 先拷贝一份数组,在拷贝的数组中写数据,写完后丢弃原来的数组,指向拷贝后的数组
适用于读多写少,因为读取过多导致拷贝数组的量过多,最后导致栈溢出,最终一致性,不是实时性的
```

#### 泛型
> 泛型就是将类型参数化。定义在类,接口,方法时这个类型形参将在创建对象,调用方法时动态的指定

```java
//泛型类
public final class Optional<T> {
    //? 类型统配符:代表可以代替任何具体类型参数
    private static final Optional<?> EMPTY = new Optional<>();
    private final T value;
    //泛型方法
    public static < E > void printArray( E[] inputArray ){
    	for ( E element : inputArray ){
    	}
	}
}
```

#### 注解
> 作用：注解又称 Java 标注,可以通过反射获取标注内容(如被标注的方法,类),从而通过反射实现一些自定义功能

```java
//元注解介绍
@Target({ElementType.TYPE})//注解的作用目标
@Retention(RetentionPolicy.RUNTIME) //注解的生命周期
@Documented//注解是否应当被包含在 JavaDoc 文档中
@Indexed//是否允许子类继承该注解
public @interface Component {
    String value() default "";
}
```

#### 反射
> 在运行时能够动态的获取类的信息和动态调用对象的方法和属性的能力 <br>
> https://juejin.cn/post/6864324335654404104#heading-13



#### 异常

```
异常就是何时何地报出什么类型的错误,用于程序的健壮性,容错性和系统的可维护
异常体系：
 Throwable
 |       						   |
 ERROR(JVM异常)               Exception
    				|        		  					|
 RuntimeException(不可预知的程序异常,如空指针)  checked(编译异常,可预知的,编译器进行校验的异常,如文件找不到)


异常处理机制：
1. 捕获异常 try catch finally           (如果finally存在,执行try或者catch中的return语句之前，都会先执行finally语句)
2. 声明异常 throws IOException          (定义未知范围的不稳定的代码块,try catch用来捕获已知范围)
3. 抛出异常 throw new RuntimeException  (主动抛出异常,常用日志切面捕获)

异常跟踪栈：e.printStackTrace()
```

#### 流
> 以程序为主体,往程序输入为输入流,从程序输出为输出流

#### jdk8

```
1. 接口支持非抽象方法的实现,default修饰即可
2. lambda写法,就是匿名函数的简化
3. 函数式接口，将行为参数化 @FunctionInterface
4. 提供Stream的流编程语法糖
5. 提供Optional接口处理空指针
6. 提供了LocalDate这种新的日期工具类
7. CompletableFuture异步请求
```

#### 代理实现方式

```
代理类就是一个代理对象,用来封装增强类的
1. 静态代理
在jvm启动前就创建好了，缺点是不灵活，不用时占内存
2. 动态代理
在jvm启动时通过入参和反射动态创建代理对象，使用时再创建，比较灵活
常用的有jdk代理，依赖于目标对象的接口
主要是用java.lang.reflect.InvocationHandler处理器接口和proxy动态生成代理对象

cglib只依赖于对象的类实现 ,依赖第三方的包 
MethodInterceptor 配置处理器接口
Enhancer 创建动态代理类
```
